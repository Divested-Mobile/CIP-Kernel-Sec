description: "\n \"The destination keyring specified to request_key() and co. is made\n\
  \ available to the process that instantiates the key (the slave process\n started\
  \ by /sbin/request-key typically).  This is passed in the\n request_key_auth struct\
  \ as the dest_keyring member.\n .\n keyctl_instantiate_key and keyctl_negate_key()\
  \ call\n get_instantiation_keyring() to get the keyring to attach the newly\n constructed\
  \ key to at the end of instantiation.  This may be given a\n specific keyring into\
  \ which a link will be made later, or it may be\n asked to find the keyring passed\
  \ to request_key().  In the former\n case, it returns a keyring with the refcount\
  \ incremented by\n lookup_user_key(); in the latter case, it returns the keyring\
  \ from the\n request_key_auth struct - and does _not_ increment the refcount.\n\
  \ .\n The latter case will eventually result in an oops when the keyring\n prematurely\
  \ runs out of references and gets destroyed.  The effect may\n take some time to\
  \ show up as the key is destroyed lazily. \n .\n To fix this, the keyring returned\
  \ by get_instantiation_keyring() must\n always have its refcount incremented, no\
  \ matter where it comes from.\""
references:
- https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3624
- http://www.kernel.org/pub/linux/kernel/v2.6/testing/ChangeLog-2.6.32-rc5
- https://ubuntu.com/security/notices/USN-864-1
comments:
  debian/jmm: Introduced in 2.6.29-rc1
fixed-by:
  mainline: [21279cfa107af07ef985539ac0de2152b9cba5f5, 7a99333e851ef087c7cd836950900602f0843c24]
