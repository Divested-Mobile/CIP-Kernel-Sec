description: 'net: Negative socket receive buffer size permitted'
references:
- https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-6704
- http://www.openwall.com/lists/oss-security/2016/12/02
comments:
  debian/bwh: |-
    Prior to commit 82981930125a "net: cleanups in sock_setsockopt()":
    - The comparison with SOCK_MIN_SNDBUF used type int, so it
    rejected negative values
    - The comparison with SOCK_MIN_RCVBUF used type size_t, so it did
    *not* reject negative values
    - The comparisons of val with sysctl_wmem_max used type u32, so
    they rejected negative values *unless* sysctl_wmem_max >=
    1 << 30 (and why would you set it that high?!)
    So it was possible to set a negative value for sock::sk_rcvbuf
    through SO_RCVBUFFORCE (escalation from CAP_NET_ADMIN to kernel)
    or through SO_RCVBUF (escalation from user to kernel) iff
    sysctl_wmem_max was large enough.
  ubuntu/sbeattie: |-
    it's not possible to exploit this via unprivileged
      SO_SNDBUF/SO_RCVBUF setsockopt() calls, as passing a signed value that is
      negative but when multiplied by 2 turns positive first gets compared
      against the unsigned int sysctl_wmem_max value to see if its larger
      than that. Because sysctl_wmem_max is unsigned, the compiler treats
      the value passed as unsigned, and thus a "negative" value turns into
      a large positive value, and runs afoul of this check.
reporters:
- Andrey Konovalov
fixed-by:
  debian/buster-security: &id001 ['version:debian/3.8.11-1']
  debian/stretch-security: *id001
  mainline: [82981930125abfd39d7c8378a9cfdf5e1be2002b]
