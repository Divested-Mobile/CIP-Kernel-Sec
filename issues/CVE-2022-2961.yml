description: race condition in rose_bind()
references:
- https://bugzilla.redhat.com/show_bug.cgi?id=2120595
- https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-2961
comments:
  debian/bwh: |-
    This is not fixed by commit 2df91e397d85.  The problem is that
    rose_bind() doesn't prevent two concurrent bind calls on the same
    socket from succeeding.  It checks that the SOCK_ZAPPED flag is set
    at the top, and clears it at the bottom, leaving a race condition
    between those bit operations.
    In bullseye and newer releases this is mitigated because we
    disabled auto-loading of the rose module.
  debian/carnil: |-
    Possible fix is 2df91e397d85 ("net: rose: add netdev ref
    tracker to 'struct rose_sock'") but as of 2022-08-30 no
    clarification in RHBZ#2120595.
  masami: |-
    A use-after-free bug was found in the Amateur Radio X.25 Packet
    Layer Protocol (PLP Rose). There is a race condition bug in
    rose_bind(). If an attacker succeeded race, it will
    case use-after-free bug.
    No CIP member enables CONFIG_ROSE.
  ubuntu/sbeattie: |-
    this is possibly addressed by 2df91e397d85 ("net: rose:
      add netdev ref tracker to 'struct rose_sock'") (v6.0-rc1)
