description: race condition in rose_bind()
references:
- https://bugzilla.redhat.com/show_bug.cgi?id=2120595
- https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-2961
- https://bugzilla.suse.com/show_bug.cgi?id=1202660
comments:
  debian/bwh: |-
    This is not fixed by commit 2df91e397d85.  The problem is that
    rose_bind() doesn't prevent two concurrent bind calls on the same
    socket from succeeding.  It checks that the SOCK_ZAPPED flag is set
    at the top, and clears it at the bottom, leaving a race condition
    between those bit operations.
    In bullseye and newer releases this is mitigated because we
    disabled auto-loading of the rose module.
  debian/carnil: |-
    Possible fix is 2df91e397d85 ("net: rose: add netdev ref
    tracker to 'struct rose_sock'") but as of 2022-08-30 no
    clarification in RHBZ#2120595.
  masami: |-
    A use-after-free bug was found in the Amateur Radio X.25 Packet
    Layer Protocol (PLP Rose). There is a race condition bug in
    rose_bind(). If an attacker succeeded race, it will
    case use-after-free bug.
    No CIP member enables CONFIG_ROSE.
  ubuntu/sbeattie: |-
    this is not addressed by 2df91e397d85 ("net: rose: add
      netdev ref tracker to 'struct rose_sock'") (v6.0-rc1) according
      to Red Hat.
    unfixed upstream as of 2023.01.10
ignore:
  cip/4.19: No CIP member uses ROSE driver
  cip/4.19-rt: No CIP member uses ROSE driver
  cip/4.4: No CIP member uses ROSE driver
  cip/4.4-rt: No CIP member uses ROSE driver
  cip/4.4-st: No CIP member uses ROSE driver
  cip/5.10: No CIP member uses ROSE driver
  cip/5.10-rt: No CIP member uses ROSE driver
  cip/6.1: No CIP member uses ROSE driver
  cip/6.1-rt: No CIP member uses ROSE driver
