description: |-
  In the Linux kernel, the following vulnerability has been resolved:
  can: mcp251x: fix deadlock if an interrupt occurs during mcp251x_open
  The mcp251x_hw_wake() function is called with the mpc_lock mutex held and
  disables the interrupt handler so that no interrupts can be processed while
  waking the device. If an interrupt has already occurred then waiting for
  the interrupt handler to complete will deadlock because it will be trying
  to acquire the same mutex.
  CPU0                           CPU1
  ----                           ----
  mcp251x_open()
   mutex_lock(&priv->mcp_lock)
    request_threaded_irq()
                                 <interrupt>
                                 mcp251x_can_ist()
                                  mutex_lock(&priv->mcp_lock)
    mcp251x_hw_wake()
     disable_irq() <-- deadlock
  Use disable_irq_nosync() instead because the interrupt handler does
  everything while holding the mutex so it doesn't matter if it's still
  running.
references:
- https://www.cve.org/CVERecord?id=CVE-2024-46791
- https://git.kernel.org/linus/7dd9c26bd6cf679bcfdef01a8659791aa6487a29
- https://git.kernel.org/stable/c/3a49b6b1caf5cefc05264d29079d52c99cb188e0
- https://git.kernel.org/stable/c/513c8fc189b52f7922e36bdca58997482b198f0e
- https://git.kernel.org/stable/c/f7ab9e14b23a3eac6714bdc4dba244d8aa1ef646
- https://git.kernel.org/stable/c/8fecde9c3f9a4b97b68bb97c9f47e5b662586ba7
- https://git.kernel.org/stable/c/e554113a1cd2a9cfc6c7af7bdea2141c5757e188
- https://git.kernel.org/stable/c/7dd9c26bd6cf679bcfdef01a8659791aa6487a29
fixed-by:
  mainline: [7dd9c26bd6cf679bcfdef01a8659791aa6487a29]
  stable/5.10: [3a49b6b1caf5cefc05264d29079d52c99cb188e0]
  stable/5.15: [513c8fc189b52f7922e36bdca58997482b198f0e]
  stable/6.1: [f7ab9e14b23a3eac6714bdc4dba244d8aa1ef646]
  stable/6.10: [e554113a1cd2a9cfc6c7af7bdea2141c5757e188]
  stable/6.6: [8fecde9c3f9a4b97b68bb97c9f47e5b662586ba7]
